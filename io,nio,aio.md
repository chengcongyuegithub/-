# io,nio,aio
## 异步和同步，阻塞和非阻塞
同步:发起一个请求之后，被调用者如果没有处理完就不返回
异步:发起一个请求之后，被调用者会立刻返回其接收到了信息，调用者期间可以做其他事情，我们可以通过回调事件等机制获取到结果
阻塞:发起一个请求，当前线程会一直等待结果，无法做其他的事情
非阻塞:非阻塞就是发起一个请求，当前线程不会挂起，可以先去做其他的事情
### 同步阻塞，同步非阻塞，异步非阻塞
烧水了例子
## bio
同步阻塞io，数据的读写阻塞在一个线程中完成
### 传统bio
一个请求一个应答，如果有一个连接什么也不做，着就会造成不必要的开销，我们可以使用线程池来使得线程的创建回收成本降低。
并发量增加，线程是宝贵的资源，创建线程和销毁线程，切换线程都是成本很高的操作，在Linux中，创建线程和销毁线程都是重量级的操作。如果并发量急剧升高，导致线程急剧升高，然后线程堆栈溢出，创建线程失败，最终导致无法对外提供服务。
### 伪异步bio
通过线程池和任务队列可以实现伪异步的I/O，我们将新的接入socket转化为一个task，然后传递给线程池，线程池维护一个消息队列和n个活跃的线程，我们对消息队列中的任务进行处理。因为线程池可以设置最大连接和最小连接，所以无论有多少个线程，都不会导致资源的耗尽和宕机。
### bio的适用场景
当连接数是不特别多的时候，我们可以适用bio，使得每一个线程都专注一自己的io。
高并发就无能为力
## nio
### nio简介
nio是jdk1.4之后引用的，同步非阻塞的io。io的socket和serverSocket分别对应这个socketChannel和serverSocketChannel
### nio的特性/nio和io的区别
先回答，nio流是非阻塞的，io是阻塞的
(1),io是阻塞的，nio是非阻塞的
nio是非阻塞的，当我们一个单线程从通道读数据到buffer，我们可以继续做其他的事情，等待读取到buffer之后，线程可以继续处理。写数据还是一样的。当我们写数据到通道，不需要等待它写完毕，就可以去做其他的事情。
io在执行write和read的时候，我们就阻塞只能够等待操作完成。
(2),缓冲区
buffer是一个对象，nio通过缓冲区进行读写，io通过流进行读写。
(3),channel
通道是双向的，可读也可以写，流是单向的，无论读写，buffer都只可以和channel进行交互。因为buffer，我们的channl可以异步的读写。
(4),selector
选择器通过单个线程来提高效率。使用较少的线程来处理这些通道。线程的切换成本较高，为了提高效率选择器是有用的。
### nio读写的方式
读数据
channel----->buffer
写数据
channel<-----buffer
```
JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%
项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug
```
## aio
是基于事件和回调机制的。在应用操作的时候，不会阻塞在那里。后台处理完成，会进行其他的操作。
AIO是异步IO的缩写，我们的NIO还是同步的，提供了非阻塞的方法。我们的NIO的IO行为还是同步的，
```
对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。
```