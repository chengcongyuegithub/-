# 线程
## 什么是线程和进程？
### 什么是进程？
进程是应用程序的执行过程，系统运行程序的基本单位，进程是动态的。系统运行一个应用程序，就是一个进程从创建到消亡的过程。
在java中，我们运行一个jvm程序，从mian方法进入，这个就是开启一个进程，mian方法是这个进程的主线程。
### 什么是线程？
线程是进程的更小的单位。一个进程在运行过程中会产生多个线程。多个线程是共享进程的堆和方法区的资源的，每个线程都已自己的程序计数器，虚拟机栈，本地方法栈。
在进程中，多个线程切换执行，负担较小，线程也叫轻量级进程。
```
一个java程序是有多个线程共同运行
```
## 线程和进程的关系，区别以及优缺点
从jvm的角度
java虚拟机的运行时区域
线程共享的区域  堆和方法区（运行时常量池）
线程私有的区域  程序计数器，虚拟机栈，本地方法栈
直接内存
`每个线程都有自己的程序计数器，虚拟机栈和本地方法栈，在一个进程中，多个线程共享堆和方法区`
线程是进程的更小的单位，进程之间都是独立，线程之间有可能相会影响。
### 为什么程序计数器是私有的？
字节码解释器通过程序计数器依次读取Java代码，实现Java代码的流程控制
在多线程下，程序计数器用来记录当前线程的执行位置，当CPU再次回到当前的线程的时候，从记录的位置开始执行。
程序计数器私有就是为了线程切换可以来到正确的位置
### 为什么虚拟机栈和本地方法栈是私有的？
虚拟机栈：每一次执行java方法，就会创建一个栈帧保存局部变量表，操作数栈和常量池引用。一个Java方法从进入到执行完毕的过程，就是一个栈帧从虚拟机栈入栈到出栈的过程
本地方法栈：和虚拟机栈的作用相似，虚拟机栈执行的是java方法(字节码)，本地方法栈执行的是native方法
`局部变量不被其他的线程访问到，线程私有`
### 为什么堆和方法区是公共的？
堆存放的就是创建的对象，方法区存放的是已被加载的类信息，常量，静态变量，即时编译之后的代码。
## 并行和并发
并发：在一段时间内，多个任务在执行（单位时间内不一定多个任务执行）
并行：在单位时间内，多个任务执行
## 为什么要使用多线程？
从计算机的层面上来说：线程可以比作是更轻量级的进程。线程是更小的调度单位，线程之间的切换和调度的成本远远小于进程。多核CPU使得多个线程可以同时运行，减少了上下文的切换。
从互联网的趋势来看：现在系统都是百万级，千万级的并发量。多线程编程是开发并发系统的基础，利用多线程机制可以提供系统的并发能力和性能。
在单核时代，多线程为了提高CPU和IO设备的综合利用率，CPU和IO设备能够同时运行
在多核时代，多线程为了提高CPU的利用率，多个线程使得多个CPU被利用到
## 使用多线程会带来什么问题？
上下文切换：切换线程损耗性能，过于频繁的切换线程就无法发挥多线程编程的优势
线程安全：死锁
## 线程的生命周期和状态？
NEW 初始化状态，表示线程被创建，但是还没有执行start()方法
RUNNABLE 运行状态 将就绪状态和运行两种状态
通过系统调度可以由就绪----->运行
通过yield()方法可以由运行----->调度
blocked状态，阻塞状态，表示等待同步方法(锁)的释放
waiting状态 等待状态，当前状态的线程需要其他线程做一些特别的动作
time_waiting状态 等待超时状态，它可以在一定时间内自行返回
terminated状态 当前线程已经执行完毕

线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。
当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。
## 什么是上下文切换?
运行的线程数一般大于CPU核数，而单位时间内一个CPU只能够处理一个线程，为了让这些线程可以有效的执行，CPU采取的方式是时间轮转的方式。当一个线程用完时间片就会进入就绪状态，这个过程就是上下文切换。

当前线程用完时间片之后，保存当前的状态，以便一下次切换到这个任务，可以再加载这个任务的状态
任务从保存到再加载就是一次上下文切换
## 什么是线程死锁？如何避免死锁？
多个线程同时阻塞，它们中的一个或者是全部都在等待着某个资源被释放。线程被无限期的终止，所以是不可能正常的结束的。
当两个线程A，B分别占用着a和b，它们都想获取对方的资源，双方等待进入死锁状态
(synchronized嵌套)
### 产生死锁的条件
互斥条件：一个资源在一个时刻只能够被一个线程所占用
请求和保持条件：一个进程在请求其他资源时，会对占用的资源保持不放
不剥夺条件：一个线程在获取到资源到释放资源，其他线程不能够强行剥夺
循环等待条件：若干个线程形成头尾相接的循环等待关系
### 如果避免死锁
破坏其中的条件
互斥条件，请求和保持条件，不剥夺条件，循环等待条件
靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
## 说说 sleep() 方法和 wait() 方法区别和共同点?
最常见的区别就是:wait()释放了锁，sleep()没有释放锁
wait()和sleep()都用作线程的暂停
wait()主要是用作线程间的通信，sleep主要是用作线程的暂停
wait()方法调用之后，需要其他的线程调用notify()或者是notifyAll()才能够苏醒。
sleep()在超过时间之后，就会进入可执行状态
wait(long)也是在超时时间之后，会进入可执行状态
## 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
new完一个Thread，在执行start方法就会进入到可执行状态，这个时候获取到时间片，就会进入到运行状态，会自动执行run方法，这个是多线程的操作。如果执行run方法，相当于是在main方法中运行一个普通方法，并不是多线程的操作。

## 说一说对Synchronized的理解
Synchronized关键字是为了解决多线程访问资源的同步性。被Synchronized修改的方法或者是同步块在任意时刻只能被一个线程访问。
Synchronized重量级锁，是因为监视器是依靠操作系统的mutex lock实现的。Java线程是在操作系统的原生线程上实现的，线程的切换需要操作系统从用户态转化到内核态，这操作时间成本较高，这就是Synchronized效率低的原因。在jdk1.6之后JVM对Synchronized做出优化，自旋锁，适应性自旋锁，锁消除，锁粗化，偏向锁，轻量级锁
## 说说自己是怎么使用 synchronized 关键字
使用synchronized主要由三种方式：修饰实例方法，修饰静态方法，修饰代码块
修饰实例方法：表示给实例方法对应的实例对象加锁，进入代码块需要获取到实例对象的锁
修饰静态方法：表示给当前类对象加锁，进入代码块需要获取到当前类对象的锁。如果线程A进入到了当前实例对象的非静态synchronized方法，如果线程B进入到了当前实例对象的静态synchronized方法，这个是允许的，并不会发送互斥现象。
`进入静态方法是获取类对象的锁，进入非静态方法是获取实例对象的锁`
修饰代码块：给指定的对象加锁，进入代码块要给指定的对象加锁。
### 单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！
```
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        //模拟一种情况，两个线程同时进入到第一个if中，依次执行synchronized代码块中的方法
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                //第二个发现不是空的就不执行了 
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
几个要点privat volatile static 
private构造方法
getInstance
if synchronized if 初始化
volatile防止指令重排序，不使用的化有可能得到一个未初始化的实例
uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：
为 uniqueInstance 分配内存空间
初始化 uniqueInstance
将 uniqueInstance 指向分配的内存地址
但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。
## 讲一下 synchronized 关键字的底层原理
synchronized是jvm层面的。
我们在执行一个同步代码块的时候，monitorEnter和monitorExit。monitorEnter表示尝试获取锁进入到这个同步代码块中，monitorExit表示释放锁执行完毕这个同步代码块。
monitor位于每个对象的头部，任何对象都是可以作为锁的原因。
当锁的计数器开始为0，获取之后锁的计数器为1，设为0表示被释放。
执行同步方法没有使用monitorEnter和monitorExit，而是ACC_SYNCHRONIZED的标识，表示这个方法是一个同步方法。
## 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗
锁优化的方式，偏向锁，轻量级锁，自旋锁，适应性自旋锁，锁消除，锁粗化 
锁有四种状态，无锁状态，偏向锁，轻量级锁，重量级锁
锁可以升级不能够降级，提高加锁和释放锁的效率
### 偏向锁
偏向锁和轻量级锁的目的相同，都是为了在没有多线程的压力下，减少传统的重量级锁使用操作系统互斥量的性能消耗，不过轻量级锁使用的CAS操作代替操作系统互斥量，而偏向锁是直接将锁给消除。
偏向锁表示偏向于第一个获取它的线程，如果没有其他线程的参与，那么持有偏向锁的线程就不需要同步。
使用偏向锁时候之后，不会立刻碰撞成为重量级锁，会升级成为轻量级锁。
### 轻量级锁
如果获取偏向锁失败，会采取轻量级锁的优化方式。在没有多线程的竞争下，我们避免传统的重量级锁使用操作系统的互斥量的时间消耗，我们采用CAS的方式，不需要申请互斥量。
如果没有竞争，我们就是采用CAS来降低操作系统互斥量的消耗。如果存在竞争，我们在使用互斥量的同时还会使用CAS操作。
所以在有竞争的情况下，轻量级锁的性能消耗更大。
竞争就会导致轻量级锁膨胀成为重量级锁
### 自旋锁和自适应自旋锁
轻量级锁之后，我们为了避免操作系统层面的阻塞，我们使用自旋锁的优化手段。
互斥同步性能消耗最大的就是线程的阻塞，我们在挂起/恢复线程都需要在内核态完成(用户态转化为内核态)，虚拟机团队考虑，让线程等待一段时间但不被挂起，我们就给等待的线程一个忙循环，这个就叫做自旋。
```
自旋和互斥都是保护共享资源的一种锁机制。自旋锁和互斥锁比较类似，为了解决某些资源的互斥使用。在同一个时刻只有一个保持者，同一时刻只有一个调度任务获取到锁。互斥，等待的线程休眠，自旋不会休眠，而是在循环着等待锁
```
自适应自旋锁等待的时间不固定了，依照上面的情况来判定
### 锁消除
如果不会产生竞争，那么在编译器阶段，就进行消除
### 锁粗化
同步代码块的作用域小，如果存在锁竞争，等待线程也可以更快的拿到锁
## 谈谈 synchronized和ReentrantLock 的区别
都是可重入锁。
```
可重入锁的概念：自己可以再次获取自己的内部锁。当一个线程获取到某个对象的锁，此时锁还没有释放，如果这个线程向继续获取还是可以继续获取的，如果锁不可重入的话，那么就会造成死锁。同一个线程每获取到一次锁，对象的锁计数器就会+1，为0表示锁被释放
```
synchronized是依赖于JVM的而ReentrantLock是依赖于API的。
```
synchronized是依赖于JVM的实现的，jdk1.6之后的优化也是jvm层面的，对对象是不可见的。ReentrantLock是基于API的需要lock()和unLock()方法和try/finally配合使用
```
ReentrantLock的高级特性，1，等待可中断
                                           2，可实现公平锁
                                           3，可实现选择性通知
```
lock.lockInterruptibly()等待的线程可以放弃等待，去做其他的事情
```
```
默认是不公平的锁，可以实现公平锁，构造方法传入参数。公平锁就是先等待的线程先获取到锁。
```
```
synchronized是通过wait()/notify(),notifyAll()实现等待通知/机制，ReentrantLock也可以实现，通过condition和newCondition()接口。在一个lock上我们可以创建多个condition实例，线程对象可以注册到有选择性的condition上去，从而进行有选择的线程通知，在调度上更加的灵活，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。
```
性能不是选择的标准
## volatile关键字
### 内存模型
线程会将变量保存到本地内存上，而不是对主存进行读写。造成的问题就是，一个线程对主存的值进行了修改，而其他咸亨还在使用它本都内存的中变量的拷贝，这就造成了线程的不一致。
要解决这个问题就要使用volatile，每一次的修改都要同步到主存中去。
保存变量的可见性和防止重排序
### 说说 synchronized 关键字和 volatile 关键字的区别
1，volatile是轻量级的线程同步实现，所以性能会更加好一点，不过在jdk1.6之后，synchronized进行了偏向锁等一系列的优化，所以使用synchronized的场景还是更多一点
2，多线程访问volatile不会发生阻塞，而synchronized就会发送阻塞
3，volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
4，volatile线程之间的可见性，synchronized实现的是多线程之间资源的同步访问
## ThreadLocal
### ThreadLocal作用
#### 介绍1
我们创建的变量是所有线程都可以访问修改的，我们现在想要每一个线程都拥有自己的本地变量副本，这就用到了我们的ThreadLocal，ThreadLocal就是我们每一个线程都绑定自己的值，相当于一个容器，其中的每一个线程都拥有自己的私有数据。
#### 介绍2
ThreadLocal，顾名思义就是线程的本地变量，每一个线程都拥有此变量的一个副本，也就是ThreadLocal类型变量的副本，人手一份，各用各的
### ThreadLocal的常用方法
我们创建一个ThreadLocal类型的变量，每一个线程访问这个ThreadLocal变量，就会在本地创建一个此类型的副本，我们通过get和set方法获取到本地默认值或者修改为本地副本的值，避免了线程安全问题
#### set()方法
从当前线程中获取到ThreadLocalMap，如果不为null，将ThreadLocal作为key传入，set传入的值作为value
如果为空，先创建map，在执行上面的操作
#### get()方法
通过当前线程thread实例获取到它所维护的threadLocalMap，然后以当前threadLocal实例为key获取该map中的键值对（Entry），若Entry不为null则返回Entry的value。如果获取threadLocalMap为null或者Entry为null的话，就以当前threadLocal为Key，value为null存入map后，并返回null。
### 内存泄漏
ThreadLocalMap是threadLocal的一个静态内部类。ThreadLocalMap就是一个map，内部是一个entry类型的数组，这个内存key就是ThreadLocal，value就是我们传入的值，我们看一看一个entry的构造方法
```
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;
    
    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```
key是弱引用，value是强引用。
ThreadLocalMap中的threadLocal对应的key是弱引用，value是强引用，在key没有被强引用的情况下，key会被GC回收，而value不会被回收，这就出现了key为空，value不为空的entry的情况，这样就会引起内存泄漏。在get，set，remove中提供了处理key为null的情况，我们在使用完ThreadLocal最好手动调用remove方法
## 线程池
### 为什么要使用线程池？
降低资源的消耗
通过重复利用已创建的线程来减少创建和消耗线程。
提高响应速度
在任务到达的时候，可以不用等线程的创建就直接执行任务
提高线程的可管理性
线程不断的创建会影响性能，通过线程池统一的调度，监控和调优
### Runnable和Callable接口的区别
runnable接口没有返回值结果，callable有返回值
Executors可以实现runnable和callable的相互转化
### execute和submit的区别
execute执行一个没有返回值结果的任务，我们没有办法判断执行是否成功。
submit执行一个有返回值的结果，返回值为future，我们可以通过future的get方法判断任务是否执行成功。
### 如何创建线程池
通过构造方法创建ThreadPoolExecutor
通过Executor的工具类Executors创建线程池
singleThreadPool
fixedThreadExecutor
CachedThreadExecutor
## Atomic 原子类 
Atomic的原理就是CAS+volitale+native本地方法。
CAS的原理就是拿期待的值和本地的值进行对比，如果相同，则修改此值。Unsafe方法中的objectFieldOffset获取到本地原本值的内存地址，返回值为valueOffset。另外一个value是可见的。
## AQS
### 请你说一下自己对于AQS原理的理解
如果被请求的共享资源是空闲的，那么将当前的线程设置为有效的线程。如果当前共享资源被占用，那么就需要线程阻塞以及被唤醒时锁分配的机制。将获取不到锁的线程放入到双向队列中去。
### AQS 对资源的共享方式
独占和共享
不同的自定义同步器争用共享资源的方式不同，但是线程等待入队和出队AQS已经完成好了
### AQS使用了模板方法的设计模式
自定义的同步器继承了AQS，重写了它指定的方法，指定了自定义同步器对共享资源占有和释放的方式
自定义的同步器调用AQS的同步方法，调用AQS自己的模板方法，模板方法中调用的就是子类自己实现的方法

可以重写的
isHeldExclusive()
tryAcquire
tryRelease
tryAcquireShared
tryReleaseShared
AQS的其他方法都是final实现的
一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。
### AQS 组件总结
Semaphore
CountDownLatch
CyclicBarrier
## 乐观锁和悲观锁
悲观锁 总是假设最坏的情况，每次别人拿数据都认为数据会被修改，每次拿数据都要进行加锁，其他线程这是就会阻塞直到锁的释放，在数据库中，行锁表锁读锁写锁都使用了悲观锁，每次拿数据都会加锁。
乐观锁 总是假设最好的情况，每次别人拿数据都认为不会修改数据，但是在数据进行更新的时候会判断这期间数据有没有发生变化，可以采用版本号机制和CAS完成。适用于多读的情况，这样可以提高吞吐率。
### 使用场景
乐观锁在多读的场景下使用，这样提高吞吐率。如果时多写的场景下，上层会频繁的执行retry，这个时候适用于悲观锁。
### 乐观锁的两种实现机制
#### 版本号机制
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
例子
#### CAS操作
在不使用锁的情况下，实现多线程之间的变量同步，在没有线程被阻塞的情况下，实现变量的同步。涉及到三个值
V  内存值
A  进行比较的值
B 新值
仅当V等于A的时候，将V修改为B，否则不断的自旋
#### CAS的缺点
1，ABA问题
我们读取到的V是A，准备修改的时候还是A，说明期间没有被修改吗，不能说明，可能期间V修改为了B，然后又改为A，这也就是ABA问题。
AtomicStampedReference先通过compareAndSet比较V的值，然后再比较当前的标志和预期的标志，两个都相同，才肯一进行变量的修改
2，循环时间长开销大
自旋CAS表示如果不成功就会一直的执行，这样会消耗CPU的的执行开销。JVM如果支持pause的话，会在效率上有一定的提升，pause指令有两个作用
延迟流水线执行指令
避免在退出循环的时候内存顺序冲突
3，只能保证一个变量的同步共享
CAS只对单个变量有效，如果操作是横跨多个共享变量时CAS无效。但是从jdk1.5之后，AtomicReference保证了对象的原子性，我们可以把多个对象放入到对象中，实现多个变量的同步共享
#### CAS与synchronized的使用情景
CAS适用于写少的场景，synchronized适用于写多的场景
1，在冲突较少的场景下，使用synchronized产生的线程的阻塞和恢复都是会导致操作系统内核态和阻塞态的切换，比较耗费CPU的性能。使用CAS，无需切换线程，不需要进入内核，可以获得更高的性能
2，在冲突较多的场景下，CAS自旋的概率也就大了，消耗CPU的性能。
synchronized
在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。


## 参考博客
[27篇文章详细总结Java并发基础知识](https://juejin.im/post/5aeed586f265da0b8262b019)