# JVM
## 概述
java程序员不需要像C/C++程序员那样new完一个对象还需要对它进行delete/free操作，Java程序员将这个操作交给了jvm虚拟机，当出现内存溢出和内存泄漏的情况时，理解jvm，才可以进行排查
## 运行时数据区域
jdk1.8之前和jdk1.8之后
### 线程私有
#### 程序计数器
两个作用
字节码解释器，通过程序计数器，得到下一条需要执行的字节码指令，完成流程控制
保留当前线程的执行位置，切换线程可以来到正确的位置
```
流程控制，保留现场
```
不会发生内存溢出，生命周期随着线程的创建而创建，随着线程的消亡而消亡
#### Java虚拟机栈
描述Java方法的内存模型，每执行一个方法，就是将栈帧入栈，每一个栈帧包括局部变量表，操作数栈，动态链接，方法出口。局部变量表中包括编译时用的的数据类型，和对象引用
#### 本地方法栈
Java虚拟机栈就是Java方法(字节码)，本地方法就是native方法
### 线程共享
#### 堆
对象以及数组都是在堆上进行内存分配的。
堆也是垃圾回收最频繁的区域，GC堆。堆可以分为新生代和老年代，更细致的可以分为Eden 空间、From Survivor、To Survivor 空间,tentired
最开始分配在eden分配，经过一次新生代的垃圾回收，存活下来的对象就会进入s1，s2区域，并且年龄会变为1，当年龄增加到一定的值，就会晋升为老年代。对象晋升为老年代的值可以设置
-XX:MaxTenuringThreshold
#### 方法区
方法区也被称为永久代。方法区存放类的信息，常量，静态变量，即时编译的代码。Java虚拟机将它定义为堆的一部分，但是它有一个别名叫no-heap，也就是为了和堆区别开来。
##### 方法区和永久代的关系
永久代相当于时java虚拟机规范中的堆方法区的一种实现方式。
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
##### 常用的参数
-XX:PerSize
-XX:MaxPerSize
jdk1.8之后hotspot的永久代就移除了，取而代之的是metaSpace(元空间)，也就是直接内存。
-XX:metaSpaceSize
-XX:MaxmetaSpaceSize
与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
##### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
永久代受jvm的限制，有固定的大小，而元空间会根据真机环境进行设置，只受系统内存的影响
#### 运行时常量池
jdk1.7之后，运行时常量池从方法区中移出，在java堆上开辟了一块内存区域
存放编译器的字面量和符号引用
```
字面量 文本字符串 被声明为final的常量，基本数据类型，其他
符号引用 类和结构的完全限定名 字段名称和描述符 方法名称和描述符
```
### 直接内存
直接内存不是java虚拟机运行时区域。
java在jdk1.4的nio，是使用channel和buffer的一种io，directBuffer的对象在Java堆上直接操作对外内存，避免了java内存和直接内存的来回copy。
## HotSpot 虚拟机对象探秘
### 创建对象的过程
1，类加载检查
2，分配内存
3，初始化0值
4，设置对象头
5，执行init方法
#### 类加载检查
在执行new的指令时，先去常量池查看这个指令对应的类的符号引用，根据这个类的符号引用，查看这个类是否被加载，解析，初始化。如果没有话，先执行类加载
#### 分配内存
在java堆上划分一块区域，两种方式，指针碰撞 空闲列表
采取哪一种
Java堆是否规整，java堆是否规整由垃圾收集器的压缩正路算法决定
指针碰撞 规整的情况
空闲列表 不规整的情况
##### 内存分配的并发问题
我们需要保证我们创建的对象是线程安全的。
CAS+失败重试
TLAB，eden上划分，现在TLAB上划分，然后采用cas+失败重试
#### 初始化零值
分配的内存空间都分配为0值，实例对象可以不初始化就直接使用
#### 初始化对象头
设置值
#### 执行init方法
### 对象的内存布局
对象头
两部分数据 存储自身的运行时数据 哈希码，GC分代年龄，锁状态
实例数据
存储实际的内容字段
对齐填充
对象大小是8的整数倍
### 对象的访问定位
栈上的reference对象访问堆上的数据
使用句柄，直接指针
1，句柄
java堆上的句柄池，对象实例数据（去堆上访问），对象类型数据（去方法区访问）
2，直接指针
各有优势，句柄不需要修改栈上的对象地址
直接指针减少了一次指针的开销
## String 类和常量池
两种创建方式
双引号创建就是从常量池中取，new就是在堆上创建一个新的对象
```
直接使用双引号声明出来的 String 对象会直接存储在常量池中。
如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。
```
```
String s1 = new String("计算机");
String s2 = s1.intern();
String s3 = "计算机";
System.out.println(s2);//计算机
System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，
System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象
```
### 字符串拼接
```
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象	  
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```
### String s1 = new String("abc");这句话创建了几个字符串对象？（重点）
创建一个或者两个。如果常量池中没有abc，那么就会在堆上创建，然后再池中创建。
如果常量池中已经存在的话，我们只在堆上创建
## 包装器和常量池
5中数据类型的在[-128,127]的范围之间，会采用常量池缓存技术
double和float不会采用
### 例子1
```
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```
```
Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
Integer i1 = new Integer(40);这种情况下会创建新的对象。
```
### 例子2
```
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

System.out.println("i1=i2   " + (i1 == i2));//true
System.out.println("i1=i2+i3   " + (i1 == i2 + i3));//true
System.out.println("i1=i4   " + (i1 == i4));//false
System.out.println("i4=i5   " + (i4 == i5));//false
System.out.println("i4=i5+i6   " + (i4 == i5 + i6));//true   
System.out.println("40=i5+i6   " + (40 == i5 + i6));//true     
```
## 字符串和包装类型的总结
都会使用到常量池，字符串中String str3=str1+str2，会在堆上创建；String str3="abc"+"cd";之后在常量池上创建。
Integer i=129；这个就会在堆上创建新对象。
i=i2+i3带+号的，自动拆装箱机制，比较的就是值

## 垃圾回收的常见面试题
1，如何判断对象是否死亡
2，强引用，软引用，弱引用，虚引用
3，如何判断一个常量是废弃常量
4，如何判断一个类是无用的类
5，垃圾回收算法有哪些算法，各有什么优点
6，HotSpot为什么分为新生代和老年代
7，垃圾回收器
8，CMS，G1
9，GC的过程
```
内存是如何分配的------>哪些垃圾需要回收------->什么时候回收------->如何回收
```
## jvm自动内存管理
jvm的自动内存管理分为两个部分，内存的分配和内存的回收。jvm内存管理的核心区域就是堆，堆是垃圾回收的主要区域，所以也被称作是GC堆。
堆分为新生代和老年代，为了更好的内存分配和内存回收
Eden，from survivor，to survivor，tentired
### 简单说一下垃圾回收机制
最开始对象的分配在Eden区上进行分配，经过一次新生代GC之后，存活下来的对象会到to survivor上去，并将他的初始年龄设置为1，每一次GC，它的年龄都会加1，在年龄变成15之后，他就会晋升为老年代。经过第一次的新生代GC，会将Eden区和From Survivor清空，这个时候我们交换From区和to区。我们要保证to区是空的，Minor GC会一直重复这样的过程，to区被填满，它就会进入到老年代。
```
对象优先在eden上面分配
大对象直接进入到老年代
长期存活的对象直接进入到老年代
```
#### 对象优先在Eden上面进行分配
垃圾回收算法都是采用分代算法的，对不同的区域采用不同的垃圾回收算法。
Minor GC
Full GC
##### 一个例子
-XX:+PrintGCDetails
内存担保机制
#### 大对象直接进入到老年代
连续的内存对象，避免内存担保机制带来性能的降低
#### 长期存活的对象直接进入到老年代
在Eden区域的对象经过一次minor GC，如果from survivor的空间够大，就会进入到from survivor区域，并且设置初始年龄为1，每经过一次GC，就会年龄+1，在年龄到达15的时候，就会进入到老年代
--XX:MaxTeuringThrehold
#### 动态对象的年龄判定
如果survivor中相同年龄的对象数量超过了空间的一半，就可以进入到老年代
### 对象已经死亡？
垃圾回收的第一步就是对对象进行判断是否死亡
判断对象已经死亡，引用计数 可达性算法
引用 强引用，软引用，弱引用，虚引用
不可达的对象并非是非死不可
判断一个常量是否是废弃常量
判断一个类是否是无用的类
#### 判断对象已经死亡
##### 引用计数
有一个地方使用它，引用计数器就加1，没有地方引用就是为0.主流虚拟机不使用这种算法，无法解决循环引用的问题
##### 可达性算法
一系列的GC Roots，开始向下搜索，如果对象可达，表示这个对象可用，表示一条引用链
#### 引用？
##### 强引用
大部分都是强引用，相当于生活中的必须品，就算是内存溢出，也不会内存回收
##### 软引用
相当于生活中可有可无的用品，如果内存足够，就不回收它，如果内存不够，就回收。可以实现内存敏感的告诉缓存。
软引用可以和一个引用队列相互关联，如果一个软引用被回收，可以将它加入到与之对应的引用队列之中
##### 弱引用
可有可无，和软引用相比，如果被垃圾回收的线程扫描到，不管内存够不够，都会回收。
对应着引用队列
##### 虚引用
任何时候都有可能被垃圾回收。
跟踪对象的被垃圾回收的活动
虚引用必须和引用队列（ReferenceQueue）联合使用。
```
当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
```
##### 总结
很少使用弱引用和虚引用。
软引用可以加速jvm对垃圾回收的回收速度，可以维护系统的安全，防止内存溢出的问题。
#### 不可达的对象并非非死不可
不可达的对象也不一定非死不可，缓刑阶段，如果第一次标记为不可达，并且没有覆盖finalize方法，或者已经执行完了finalize方法，就死了。
在第二次标记之前，如果和一个对象建立上了关联，就会真的被回收
#### 如何判断一个常量是废弃常量
常量池，如果没有引用的，就是废弃的常量
#### 判断一个类是无用的类
没有实例，classLoader被回收，class对象没有被引用
### 垃圾收集算法
#### 标记-清除算法
#### 复制算法(新生代)
#### 标记-整理算法(老年代)
#### 分代收集算法
##### hotspot为什么要分为新生代和老年代？
比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
```
新生代 存活率低
老年代 存活率高
```
### 垃圾收集器
回收算法是垃圾回收的方法论，垃圾收集器就是垃圾回收的具体实现
#### Serial收集器
#### ParNew收集器
#### Parellel Scavenge收集器
#### Serial Old收集器
#### Parallel Old收集器
#### CMS收集器
concurrent mark sweep
是一款以获取最短的停顿为目标的收集器。它适合在非常注重用户体验的应用上使用。
CMS收集器是HotSpot的第一款真正意义上的并发收集器，垃圾回收线程和用户线程同时工作
采用的是标记-清除算法
初始标记：暂停其他的线程，记录和root相连的对象，时间比较短
并发标记：同时进行用户线程和GC线程，用一个闭包结构来记录可达对象。但是不能保证记录所有的可达对象。用户线程的实时更新，GC线程可能无法保证实时性
重新标记：修正并发标记因为用户线程实时操作的发生变动的对象记录
并发清理：开启用户线程，是GC线程进行清理
缺点：
碎片，CPU资源比较敏感，无法处理浮动垃圾
#### G1收集器
面向服务器的垃圾收集器，适用于配置多个处理器以及内存容量大的机器，极高的概率满足停顿时间的同时，又具备很高的吞吐量。
并发和并行：其他的收集器需要暂停java线程来进行GC，而G1收集器充分利用CPU使得java线程和GC线程并发执行
分代收集：保留了分代的概念
空间整合：标记整理和复制算法
可预测的停顿：降低停顿时间是两个收集器的共同目标，G1还会建立可预测的时间模型。
过程如下：
初始标记，并发标记，最终标记，筛选回收
后台维护一个优先列表，每次都回收价值最大的那个标记
## JDK 监控和故障处理工具总结
### 概述
jps：  ps，java线程
jstat：虚拟机的运行数据
jinfo：虚拟机的配置信息
jmap：
jhap：
jstack：每一条线程的方法堆栈
### jps
jps -p只有id，没有类名
jps -l全类的名字
jps -v启动JVM参数
jps -m mian函数的参数
### jstat
Java虚拟机的运行状态信息
虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据
```
jstat -class vmid ：显示 ClassLoader 的相关信息；
jstat -compiler vmid ：显示 JIT 编译的相关信息；
jstat -gc vmid ：显示与 GC 相关的堆信息；
jstat -gccapacity vmid ：显示各个代的容量及使用情况；
jstat -gcnew vmid ：显示新生代信息；
jstat -gcnewcapcacity vmid ：显示新生代大小与使用情况；
jstat -gcold vmid ：显示老年代和永久代的信息；
jstat -gcoldcapacity vmid ：显示老年代的大小；
jstat -gcpermcapacity vmid ：显示永久代大小；
jstat -gcutil vmid ：显示垃圾收集信息；
```
### jinfo
实时的查看和调整java虚拟机的参数
### jmap
堆转储快照
### jhat
用户在浏览器上分析结果dump文件
### jstak
每个线程的堆栈信息
jstak来观察死锁
### JConsole:Java 监视与管理控制台
可视化工具，本地或者远程服务器java内存情况，可以细化到eden/survivor，以及gc的情况，jstack查看每一个线程，检测死锁。
## 类加载过程
将class文件加载到java虚拟机中，我们jvm要去加载这个文件。
加载------->连接--------->初始化
连接分为
验证------->准备---------->解析
### 加载
3个小过程
1，将全类名转化为二进制流
2，二进制流中的静态数据区转化为方法区的中运行时数据结构
3，生成一个class类，作为进入方法区的入口
自定义二进制流的获取方式，可以通过重写类加载器
### 连接之验证
### 连接之准备
为类变量分配内存以及赋初始值
static分配内存
实例变量会在创建对象的时候在堆上进行分配
赋初值，真正的赋值实在初始化阶段
### 连接之解析
常量池中的符号引用转化为直接引用。
类，接口，字段，类方法，接口方法，方法类型，方法句柄，调用限定符
```
符号引用  字面量
直接引用  直接定位到目标的句柄
```
程序运行的过程中符号引用是不够了，程序在执行方法的时候，我们需要明确知道方法所在位置。
解析阶段就是虚拟机将符号引用转化为直接引用的过程，直接指针或者是偏移量
### 初始化
初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。
1，要求线程安全
2，对类进行初始化的情况
```
1,new getstatic putstatic invokestatic 
2,反射
3,初始化一个类，先初始化它的父类
4,main方法的那个类
5,动态语言
```
## 类加载器
类加载器的作用就是将.class文件加入到内存
### 类加载器分类
BootstrapClassLoader(启动类加载器)
```
c++实现的最顶层的类，%JAVA_HOME%/lib目录下jar包和类
-Xbootclasspath参数指定的路径中的所有类。
```
ExtensionClassLoader(拓展类加载器)
```
主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
```
AppClassLoader(应用程序类加载器)
```
classpath下的
```
### 双亲委派机制
每个类都对应一个类加载器。协同工作的时候会默认使用双亲委派机制。
加载的时候，会看这个类是否被加载了，如果被加载的话，直接返回。没有加载的话，交给父类去处理。
当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。
从启动类加载器开始处理，如果无法处理，交给下层。
当父类加载器无法处理时，才由自己来处理。
AppClassLoader的父类加载器为ExtClassLoader ExtClassLoader的父类加载器为null，null并不代表ExtClassLoader没有父类加载器，而是 Bootstrap ClassLoader 。
```
自下而上检查是否被加载，自上而下开始加载类
```
### 双亲委派机制的好处
Java程序的稳定运行，避免类的重复加载(相同类名被不同的类加载器加载，就是不同的类)。保证了JavaAPI不被修改，防止有多个object类出现。
### 自定义类加载器
除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader。
