# JVM
## 概述
java程序员不需要像C/C++程序员那样new完一个对象还需要对它进行delete/free操作，Java程序员将这个操作交给了jvm虚拟机，当出现内存溢出和内存泄漏的情况时，理解jvm，才可以进行排查
## 运行时数据区域
jdk1.8之前和jdk1.8之后
### 线程私有
#### 程序计数器
两个作用
字节码解释器，通过程序计数器，得到下一条需要执行的字节码指令，完成流程控制
保留当前线程的执行位置，切换线程可以来到正确的位置
```
流程控制，保留现场
```
不会发生内存溢出，生命周期随着线程的创建而创建，随着线程的消亡而消亡
#### Java虚拟机栈
描述Java方法的内存模型，每执行一个方法，就是将栈帧入栈，每一个栈帧包括局部变量表，操作数栈，动态链接，方法出口。局部变量表中包括编译时用的的数据类型，和对象引用
#### 本地方法栈
Java虚拟机栈就是Java方法(字节码)，本地方法就是native方法
### 线程共享
#### 堆
对象以及数组都是在堆上进行内存分配的。
堆也是垃圾回收最频繁的区域，GC堆。堆可以分为新生代和老年代，更细致的可以分为Eden 空间、From Survivor、To Survivor 空间,tentired
最开始分配在eden分配，经过一次新生代的垃圾回收，存活下来的对象就会进入s1，s2区域，并且年龄会变为1，当年龄增加到一定的值，就会晋升为老年代。对象晋升为老年代的值可以设置
-XX:MaxTenuringThreshold
#### 方法区
方法区也被称为永久代。方法区存放类的信息，常量，静态变量，即时编译的代码。Java虚拟机将它定义为堆的一部分，但是它有一个别名叫no-heap，也就是为了和堆区别开来。
##### 方法区和永久代的关系
永久代相当于时java虚拟机规范中的堆方法区的一种实现方式。
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
##### 常用的参数
-XX:PerSize
-XX:MaxPerSize
jdk1.8之后hotspot的永久代就移除了，取而代之的是metaSpace(元空间)，也就是直接内存。
-XX:metaSpaceSize
-XX:MaxmetaSpaceSize
与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
##### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
永久代受jvm的限制，有固定的大小，而元空间会根据真机环境进行设置，只受系统内存的影响
#### 运行时常量池
jdk1.7之后，运行时常量池从方法区中移出，在java堆上开辟了一块内存区域
存放编译器的字面量和符号引用
```
字面量 文本字符串 被声明为final的常量，基本数据类型，其他
符号引用 类和结构的完全限定名 字段名称和描述符 方法名称和描述符
```
### 直接内存
直接内存不是java虚拟机运行时区域。
java在jdk1.4的nio，是使用channel和buffer的一种io，directBuffer的对象在Java堆上直接操作对外内存，避免了java内存和直接内存的来回copy。
## HotSpot 虚拟机对象探秘
### 创建对象的过程
1，类加载检查
2，分配内存
3，初始化0值
4，设置对象头
5，执行init方法
#### 类加载检查
在执行new的指令时，先去常量池查看这个指令对应的类的符号引用，根据这个类的符号引用，查看这个类是否被加载，解析，初始化。如果没有话，先执行类加载
#### 分配内存
在java堆上划分一块区域，两种方式，指针碰撞 空闲列表
采取哪一种
Java堆是否规整，java堆是否规整由垃圾收集器的压缩正路算法决定
指针碰撞 规整的情况
空闲列表 不规整的情况
##### 内存分配的并发问题
我们需要保证我们创建的对象是线程安全的。
CAS+失败重试
TLAB，eden上划分，现在TLAB上划分，然后采用cas+失败重试
#### 初始化零值
分配的内存空间都分配为0值，实例对象可以不初始化就直接使用
#### 初始化对象头
设置值
#### 执行init方法
### 对象的内存布局